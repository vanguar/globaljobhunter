Промпт для Gemini: Интеграция API Careerjet в проект GlobalJobHunter
Задача: Создать новый модуль-агрегатор careerjet_aggregator.py для интеграции API поиска работы Careerjet в существующий проект GlobalJobHunter. Код должен быть оптимальным, переиспользовать существующие компоненты и органично вписываться в архитектуру проекта.

1. Описание проекта (Контекст)
GlobalJobHunter — это веб-приложение на Python (Flask), предназначенное для помощи украинским беженцам в поиске работы.

Основной функционал: Пользователи через веб-интерфейс выбирают профессии, страны и город для поиска. Система агрегирует вакансии с нескольких внешних API и отображает их в удобном виде, сгруппировав по странам.

Ключевая особенность: Система умеет определять вакансии, подходящие для беженцев (refugee_friendly) и не требующие знания местного языка (no_language_required).

Архитектура:

Backend: Flask (app.py). Принимает запросы от фронтенда, вызывает агрегаторы и рендерит шаблоны.

Агрегаторы: Ядро системы. Существуют модули для Adzuna (adzuna_aggregator.py), Jobicy (jobicy_aggregator.py) и USAJobs (usajobs_aggregator.py). Они отвечают за запросы к API, обработку и нормализацию данных.

Frontend: HTML-шаблоны Jinja2 (index.html, results.html) и ванильный JavaScript (app.js).

Стандартизация данных: Все агрегаторы приводят полученные данные к единому формату — объекту JobVacancy.

Общие модули: В проекте уже реализованы и должны быть переиспользованы:

CacheManager: Умная система кеширования (Redis + файловый кеш) для ускорения повторных поисков и снижения нагрузки на API.

RateLimiter: Ограничитель частоты запросов к API.

JobVacancy: Стандартная структура данных (dataclass) для вакансий.

Email-подписки: Проект включает систему email-рассылок (email_service.py) и базу данных (database.py на SQLAlchemy) для хранения подписчиков и их предпочтений.

2. Необходимые файлы для загрузки
Для выполнения задачи мне понадобятся следующие файлы, чтобы понять архитектуру и переиспользовать существующий код:

app.py — Главный файл Flask-приложения. Нужен, чтобы увидеть, как вызываются и объединяются результаты от текущих агрегаторов.

adzuna_aggregator.py — (Самый важный файл). Это основной и самый сложный агрегатор. Он содержит:

Определение дата-класса JobVacancy.

Реализацию CacheManager и RateLimiter.

Логику мультиязычного поиска и определения "дружелюбных" вакансий.

Новый агрегатор должен следовать его структуре и использовать его компоненты.

base_aggregator.py (если существует) — В коде usajobs_aggregator.py упоминается наследование от этого класса. Если он есть, это идеальный шаблон для создания нового агрегатора.

jobicy_aggregator.py и usajobs_aggregator.py — Как примеры более простых, специализированных агрегаторов. Помогут понять, как интегрируются разные API.

3. План действий по интеграции Careerjet
Создание файла: Разработать код для нового файла careerjet_aggregator.py.

Класс CareerjetAggregator:

Создать класс CareerjetAggregator. Если base_aggregator.py существует, унаследовать от BaseJobAggregator.

Реализовать метод search_jobs(preferences: dict) -> list[JobVacancy].

Переиспользование компонентов:

Импортировать JobVacancy, CacheManager и RateLimiter из adzuna_aggregator.py. Не создавать их заново.

Использовать CacheManager для кеширования запросов к Careerjet. Ключ кеша должен генерироваться на основе параметров поиска (keywords, location и т.д.).

Взаимодействие с API Careerjet:

Реализовать логику запросов к API Careerjet (URL: http://public.api.careerjet.net/search).

Преобразовать preferences (список профессий и стран) в параметры, понятные Careerjet (например, keywords, location).

Обработать пагинацию для получения всех релевантных результатов (page, pagesize).

Нормализация данных:

Для каждой вакансии, полученной от Careerjet, создать экземпляр JobVacancy.

Сопоставить поля ответа Careerjet (title, company, locations, date, url и т.д.) с полями дата-класса JobVacancy.

Поле source должно иметь значение 'Careerjet'.

Интеграция в app.py:

Предоставить краткую и ясную инструкцию, как в файле app.py инициализировать CareerjetAggregator и добавить его результаты к общему списку вакансий, аналогично тому, как это сделано для Adzuna, Jobicy и др.

Код должен быть:

Эффективным: Минимум запросов к API, максимум переиспользования.

Надежным: Включать обработку ошибок (например, недоступность API, некорректный ответ).

Чистым и комментированным: Код должен быть понятным для дальнейшей поддержки.